// -*- C++ -*- generated by wxGlade 0.6.3 on Tue Feb 28 14:23:33 2012 
/*!
@file
Opdracht 4 DSB practicum (ontwerper gedeelte). Werk deze opdracht verder uit aan de hand van het kommentaar.
Assignment 4 DSB practical (designer part). Elaborate this assignment on the basis of the comments.
@version $Rev: 4067 $
@author $Author: ewout $

@copyright Copyright 2006-2020 ir drs E.J Boks, Hogeschool van Arnhem en Nijmegen. https://ese.han.nl

$Id: filterOntwerper.cpp 4067 2021-01-14 17:10:15Z ewout $
************************************************************************/

#if (InterfaceTaalNederlands)
#error  "(filterOntwerper.cpp) Student naam en nummer moeten beneden in de velden worden ingevuld."
#elif defined (InterfaceTaalEnglish)
//#error  "(filterOntwerper.cpp) Student name and number must be entered into the fields below."
#endif
/********  Naam/name     :  Daniel Velicu    ******/
/********  Studentnummer :  586799           ******/

#include <cassert>
#include <cmath>
#include <applikatie4.h>
#include "filterOntwerper.h"

#include <wx/numdlg.h>
#include <wx/filename.h>
#include <wx/txtstrm.h>
#include <wx/wfstream.h>
#include <wx/gdicmn.h>
#include <wx/app.h>

// begin wxGlade: ::extracode
// end wxGlade

#ifdef InterfaceTaalNederlands
double FilterVenster::driehoek(const Int32 n ) const
{
	/*! @note schrijf in deze funktie de code om de driehoek funktie te implementeren.
	 * @warning Let op de formule in Lynn & FÃ¼rst is niet goed. */
#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

}


double FilterVenster::hamming(const Int32 n ) const
{
	/*! @note schrijf in deze funktie de code om de Hamming funktie te implementeren. */
#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

}


double FilterVenster::sinc(const double hoek ) const
{
	/*! @note schrijf in deze funktie de code om de sinc() funktie te implementeren. */
#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

}

void FilterVenster::berekenFilterHandler(wxCommandEvent &event)
{
	/*! @note Nederlands : schrijf in deze funktie de code om de tijddomeincoefficienten
	 * van het filter te bereken.
     * Maak hier voor gebruik van de Fourier ontwerp methode (Lynn & FÃ¼rst Â§5.3)
     * voor een bandfilter:
     * h[n] = (Omega1/pi)*sinc(Omega1*n) : Dit is een laagdoorlaatfilter
     * vermenigvuldig dit in tijddomein met cos(Omega0*n) -->
     * in frequentiedomein convolueer met delta(Omega0) -->
     * verschuiving van begin LDF van 0 naar Omega0 */

	/* filter maakt gebruik van Hamming Venster :
	 * Zie boek Andriessen / Lynn & FÃ¼rst, blz 156
	 * of Lynn & FÃ¼rst, blz 150.
	 */

	/* een array van wxPoints die je kunt gebruiken om de impulsresponsie te tekenen. */
	PuntLijst impulsResponsie;

	/* Verwijder oude filter coefficienten voor de berekening begint. */
	filterCoeffs.Clear();

	wxLogDebug(_("filter berekening start."));
	wxBusyCursor bezig;

#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

	/* schakel ook de test knop nu in */
	berekeningKlaar = true;
}


void FilterVenster::berekenFreqResponsie()
{
	/*! @note schrijf in deze funktie de code om het  frequentiebeeld te bereken op
	 * basis van de tijddomeincoefficienten. */

	H_Omega.Clear();

#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

}

void FilterVenster::tekenFreqSpectrum() const
{
	/*! @note schrijf in deze funktie de code om het berekende frequentiebeeld in het
	 * venster freqDomeinGrafiek te tekenen. */
	const wxSize veld(freqDomeinGrafiek->geefTekenVeldGrootte());
	const unsigned int aantalPunten = FreqSpectrumPunten(taps);
	const auto stapGrootte = (Pi/aantalPunten);

	/* teken de lijnen van het freqdomein filter */

	/* toon het berekende venster in het frequentiedomein */
	freqDomeinGrafiek->maakSchoon();

	freqDomeinGrafiek->tekenAssenstelsel();

	const wxCoord veldEinde(-3*veld.GetHeight()/4);

	const auto schaalx = (1.0*veld.GetWidth())/(Pi);
	const auto schaaly = (3*veld.GetHeight()/(4*fabs(H_Omega_max-H_Omega_min)));

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("BLUE")), 2, wxPENSTYLE_SOLID));

	/* Teken de spectrale componenten */
	double omega=0;
	for(Teller index=0;index<aantalPunten;index++)
	{
		const auto xcoord = (wxCoord)(omega*schaalx);
		const wxPoint begin(xcoord,veldEinde);
		const wxPoint einde(xcoord,(wxCoord)(schaaly*H_Omega[index]));
		const LijnStuk lijn(begin, einde);
//		wxLogDebug(wxT("H(%.2lf) = %lf"),omega,schaaly*(*(H_Omega+index)));
		freqDomeinGrafiek->tekenLijn(lijn);
		omega+=stapGrootte;
	}

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREEN")), 3, wxPENSTYLE_SOLID));

	/* teken verticale lijnen op pi/6 */
	UInt32 omnummer=0;
	for(omega=0;omega<Pi;omega+=(Pi/6),omnummer++)
	{
		const auto xcoord = (wxCoord)(omega*schaalx);
		freqDomeinGrafiek->tekenVerticaleLijn(xcoord);
		const wxPoint tekstpunt(xcoord, freqDomeinGrafiek->geefMaxY());
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%dpi/6"),omnummer), tekstpunt);
	}

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREY")), 3, wxPENSTYLE_SOLID));
	/* teken horizontale lijnen op -10 db afstand */
	for (auto dblijn=0;dblijn>H_Omega_min;dblijn-=10)
	{
		const auto ycoord = static_cast<wxCoord>(dblijn*schaaly);
		freqDomeinGrafiek->tekenHorizontaleLijn(ycoord);
		const wxPoint tekstpunt(freqDomeinGrafiek->geefMaxX()-30,ycoord);
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%d dB"),
		                                                   static_cast<Int32>(dblijn)), tekstpunt);
	}
	/* teken beginband en stopband */
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("PINK")), 3, wxPENSTYLE_SHORT_DASH));

	/* begin vd band */
	omega = 2*Pi*filterBegin/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn((wxCoord)(omega*schaalx));
	/* eind vd band */
	omega = 2*Pi*filterEind/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn((wxCoord)(omega*schaalx));

	freqDomeinGrafiek->zetNormaleTekst(_("Demoversion"),wxPoint(FreqGrafiekBreedte-150, -20));

}

Int16 FilterVenster::berekenFixedPoint(const float flp) const
{
	/*! @note Bereken in deze funktie de conversie van floating point naar fixed point
	 * op basis van de instelling in fipBitsSpinCtrl. */

#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

}

float FilterVenster::berekenFloatingPoint(const Int16 fixp) const
{
	/*! @note Bereken in deze funktie de conversie van fixed point naar floating point
	 * op basis van de instelling in fipBitsSpinCtrl. */

#error “Dit stuk software ontbreekt / This part of the software is missing !!”
/* Geachte student,
    Dit stuk ontbreekt. Werk dit uit om de opdracht uit te voeren. 
     Honourable student,
     This part of the software is missing. Fill in your implementation to fulfill the task. */

}


#elif defined(InterfaceTaalEnglish)

double FilterVenster::triangle(const Int32 n ) const
{
	/*! @note Write in this function the code to implement the triangle function.
	 * Note the formula in Lynn & FÃ¼rst is not good.*/
/* student part here  */
    double threeangle{ 0.0 };

    threeangle = 1.0 -(double)abs(n) / ((double)orde+1.0);

    wxLogDebug(wxT("Triangle= %lf"),threeangle);

    return threeangle;
}


double FilterVenster::hamming(const Int32 n ) const
{
	/*! @note Write in this function the code to implement the Hamming function.*/
/* student part here  */
    double ham{ 0.0 };
    ham = 0.54 + 0.46 * cos(((float)n*Pi)/float (orde));

    wxLogDebug(wxT("Hamming= %lf"),ham);
    return ham;
}


double FilterVenster::sinc(const double angle ) const
{
	/*! @note Write the code in this function to implement the sinc () function. */

/* student part here  */
    double result;
    if(angle == 0 )
        result = 1;
    else
        result = sin(angle)/angle; // sinc(x)=sin(x)/x   unnormalized sinc

    return result;
}

void FilterVenster::berekenFilterHandler(wxCommandEvent &event)
{
	/*! @note Write the code to the time domain coefficients in this function
	  * of the filter.
      * Make use of the Fourier design method here (Lynn & FÃ¼rst Â§5.3)
      * for a band filter:
      * h [n] = (Omega1 / pi) * sinc (Omega1 * n): This is a low-pass filter
      * multiply this in time domain by cos (Omega0 * n) ->
      * Convolve in frequency domain with delta (Omega0) ->
      * shift from start LDF from 0 to Omega0  */

	/* filter uses Hamming Window :
	 * See book Lynn & FÃ¼rst, page 150. */

	/* an array of wxPoints that you can use to draw the impulse response */
	PointList impulseResponse;

	/* .
	 * Remove old filter coefficients before the calculation starts.*/
	filterCoeffs.Clear();

	wxLogDebug(_("filter calculation start."));
	wxBusyCursor busy;

/* student part here */

//IR FIR filter

    const double omegaB{ 2 * Pi * (filterEind - filterBegin) / sampFreq }; // inside the filter limits
    const double omegaC{ 2 * Pi * (filterBegin + filterEind) / sampFreq }; //center freq of my filter
    //filter begin, filter end are in represented by the number of the sample
    // /samplefreq = hz  = omega
    //  total number of samples/sample freq -> hz -> rad/sec

    // Formula at page 141
    //*Amplitude factor - formula 5.11
    const auto amplVersterking = 2 * (omegaB / Pi) * compute_Linear(maxVersterkingSpinCtrl->GetValue());

    //Calculating FIR filter coefficients from -M to M
    for (Int32 n = -1 * orde; n <= orde + 1; n++) {
        auto sincValue = sinc(n * omegaB);
        auto cosCenter = cosf(n * omegaC);
        auto coeffValue = amplVersterking * sincValue * cosCenter;

        //Multipling IR with window function
        switch (vensterChoice->GetSelection()) {
            case 0:
                coeffValue = coeffValue * sinc(n);
                break;
            case 1:
                //triangle
                coeffValue = coeffValue * triangle(n);
                break;
            case 2:
                //hamming
                coeffValue = coeffValue * hamming(n);
                break;
            default:
                wxLogDebug(wxT("ERROR with the IR"));
                break;
        }
        //Calculating the functions FixedPoint() and CalculateFloatingPoint()
        wxLogDebug(wxT("Coef. Value Fixed point =%d"), computeFixedPoint(coeffValue));
        wxLogDebug(wxT("Coef. Value Floating point =%lf"), computeFloatingPoint(computeFixedPoint(coeffValue)));

        //Saving coef.
        filterCoeffs.Add(computeFixedPoint(coeffValue));
        impulseResponse.Add(wxPoint(n, computeFixedPoint(coeffValue)));
    }

    //Drawing IR
    tijdDomeinGrafiek->tekenStaven(impulseResponse, true);

    //Calculation and drawing of the freq. response

    computeFreqResponse();
    drawFreqSpectrum();

	berekeningKlaar = true;
}


void FilterVenster::computeFreqResponse()
{
	/*! @note write the code to calculate the frequency image in this function
	 * basis of time domain coefficients. */

	H_Omega.Clear();


/* Student part here  */
//Determination and calculation of : Variables of Fourier Freq. transform FIR filter, with formula 5.14.

    const double omegaB = Pi * (filterEind - filterBegin) / sampFreq;
    const double amplifierLineair = compute_Linear(maxVersterkingSpinCtrl->GetValue());
    const unsigned int aantalPunten = FreqSpectrumPunten(taps);
    double omega{ 0 };
    double freqResp{ 0 };

    //Computing the freq. spectrum
    for (int count = 0; count < aantalPunten; count++)
    {
        omega = Pi * ((double)count / (double)aantalPunten);
        //Resetting the freqResp var.
        freqResp = 0.0;
        //Starting the Fourier Transform FIR filter
        for (int k = 1; k < orde + 1; k++)
        {
            freqResp += ((computeFloatingPoint(filterCoeffs[k + orde]) / 2 / amplifierLineair * cos(k * omega)));
        }

        freqResp = freqResp * 2.0;
        //Calculating just the first term in 5.14
        freqResp = freqResp + (omegaB / PI);

        //saving the results
        H_Omega.Add(compute_dB(freqResp) + maxVersterkingSpinCtrl->GetValue() + 6);
        //Adding the scale factor
    }

    //Min and Max over 0 to π in dB
    H_Omega_min = *std::min_element(H_Omega.begin(), H_Omega.end());
    H_Omega_max = *std::max_element(H_Omega.begin(), H_Omega.end());

}

void FilterVenster::drawFreqSpectrum() const
{
	/*! @notewrite in this function the code to draw the calculated frequency image in the
     * freq Domain graph window named "freqDomeinGrafiek" .*/

	const wxSize canvas(freqDomeinGrafiek->geefTekenVeldGrootte());
	const unsigned int numberOfFreqDomainPoints = FreqSpectrumPunten(taps);
	const auto stepSize = (Pi / numberOfFreqDomainPoints);

	/* toon het berekende venster in het frequentiedomein */
	freqDomeinGrafiek->maakSchoon();

	freqDomeinGrafiek->tekenAssenstelsel();

	const wxCoord veldEinde(-3 * canvas.GetHeight() / 4);

	const double schaalx = (1.0 * canvas.GetWidth()) / (Pi);
	const double schaaly = (3 * canvas.GetHeight() / (4 * fabs(H_Omega_max - H_Omega_min)));

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("BLUE")), 2, wxPENSTYLE_SOLID));

	/* Teken de spectrale componenten */
	double omega=0;
	for(Teller index=0; index < numberOfFreqDomainPoints; index++)
	{
		const wxCoord xcoord = (wxCoord)(omega*schaalx);
		const wxPoint begin(xcoord,veldEinde);
		const wxPoint einde(xcoord,(wxCoord)(schaaly*H_Omega[index]));
		const LijnStuk lijn(begin, einde);
//		wxLogDebug(wxT("H(%.2lf) = %lf"),omega,schaaly*(*(H_Omega+index)));
		freqDomeinGrafiek->tekenLijn(lijn);
		omega+=stepSize;
	}

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREEN")), 3, wxPENSTYLE_SOLID));

	/* teken verticale lijnen op pi/6 */
	UInt32 omnummer=0;
	for(omega=0;omega<Pi;omega+=(Pi/6),omnummer++)
	{
		const wxCoord xcoord = (wxCoord)(omega*schaalx);
		freqDomeinGrafiek->tekenVerticaleLijn(xcoord);
		const wxPoint tekstpunt(xcoord, freqDomeinGrafiek->geefMaxY());
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%dpi/6"),omnummer), tekstpunt);
	}

	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("GREY")), 3, wxPENSTYLE_SOLID));
	/* teken horizontale lijnen op -10 db afstand */
	for (double dblijn=0;dblijn>H_Omega_min;dblijn-=10)
	{

		const wxCoord ycoord = static_cast<wxCoord>(dblijn*schaaly);
		freqDomeinGrafiek->tekenHorizontaleLijn(ycoord);
		const wxPoint tekstpunt(freqDomeinGrafiek->geefMaxX()-30,ycoord);
		freqDomeinGrafiek->zetKleineTekst(wxString::Format(wxT("%.0f dB"),dblijn), tekstpunt);
	}
	/* teken beginband en stopband */
	freqDomeinGrafiek->zetTekenPen(wxPen( wxColour(wxT("PINK")), 3, wxPENSTYLE_SHORT_DASH));

	/* begin vd band */
	omega = 2*Pi*filterBegin/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn((wxCoord)(omega*schaalx));
	/* eind vd band */
	omega = 2*Pi*filterEind/sampFreq;
	freqDomeinGrafiek->tekenVerticaleLijn((wxCoord)(omega*schaalx));

	freqDomeinGrafiek->zetNormaleTekst(_("Assignment 4"),wxPoint(FreqGrafiekBreedte-150, -20));

}

Int16 FilterVenster::computeFixedPoint(const float flp) const
{
	/*! @note Calculate the conversion from floating point to fixed point in this function
	 * based on the setting in fipBitsSpinCtrl. */


/* student part hre */
    return static_cast<Int16>(round(flp * (1 << fipBitsSpinCtrl->GetValue())));
}

float FilterVenster::computeFloatingPoint(const Int16 fixp) const
{
	/*! @note Calculate the conversion from fixed point to floating point in this function
     * based on the setting in fipBitsSpinCtrl.*/


/* student part here  */
    return (static_cast<double>(fixp) / static_cast<double>(1 << fipBitsSpinCtrl->GetValue()));
}

#endif

void FilterVenster::OnMotion( wxMouseEvent& event )
{
	const auto winid = event.GetId();

	if (FreqGrafiekVensterID == winid)
		freqViewMuisBewegingHandler(event);
	else if (TijdGrafiekVensterID == winid)
		tijdViewMuisBewegingHandler(event);
}

void FilterVenster::OnEnterWindow( wxMouseEvent& event )
{
	const auto winid = event.GetId();

	if (FreqGrafiekVensterID == winid)
		freqViewBinnenkomstHandler(event);
	else if (TijdGrafiekVensterID == winid)
		tijdViewBinnenkomstHandler(event);
}

void FilterVenster::OnLeaveWindow( wxMouseEvent& event )
{
	const auto winid = event.GetId();

	if (FreqGrafiekVensterID == winid)
		freqViewBuitengangHandler(event);
	else if (TijdGrafiekVensterID == winid)
		tijdViewBuitengangHandler(event);
}



void FilterVenster::tijdViewMuisBewegingHandler(wxMouseEvent &event)
{
#ifndef ExtraOpties
	event.Skip();
#else
	if (true == tijdDomeinCoords->IsEnabled())
	{

		const wxPoint mouseCoord(tijdDomeinGrafiek->converteerMuisPositie(const_cast<wxMouseEvent &>(event)));



 /*student part here  */

	}
#endif
}

void FilterVenster::freqViewMuisBewegingHandler(wxMouseEvent &event)
{
#ifndef ExtraOpties
	event.Skip();
#else
	if (true == freqDomeinCoords->IsEnabled())
	{

		const wxPoint muiscoord(freqDomeinGrafiek->converteerMuisPositie(const_cast<wxMouseEvent &>(event)));

 /* Student part here  */

	}
#endif
}

/*********** Geachte studenten , hieronder NIETS veranderen.              ******/
/*********** Honoured students, do NOT alter ANYTHING below this line.  ******/


FilterVenster::FilterVenster() : wxFrame(nullptr, wxID_ANY,_("FIR Filter Designer"),
		wxDefaultPosition, wxDefaultSize,
                                         (wxDEFAULT_DIALOG_STYLE|wxMINIMIZE_BOX|wxMAXIMIZE_BOX|wxRESIZE_BORDER|
                                          wxSYSTEM_MENU|wxCAPTION|wxFULL_REPAINT_ON_RESIZE)),
                                          FilterDesignerBasis(),
                                 klok(this,KlokVerlopenID)
{
				// begin wxGlade: FilterVenster::FilterVenster
				hoofdPaneel = new wxPanel(this, wxID_ANY);
				testPaneel = new wxScrolledWindow(hoofdPaneel, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxBORDER_SIMPLE|wxTAB_TRAVERSAL);
				venster_menubar = new wxMenuBar();
				Bestandmenu = new wxMenu();
				Bestandmenu->Append(wxID_ABOUT, _("About"), wxEmptyString);
				Connect(wxID_ABOUT, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(FilterVenster::toonCopyrightHandler));
				Bestandmenu->Append(wxID_EXIT, _("Quit\tCtrl+Q"), wxEmptyString);
				Connect(wxID_EXIT, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(FilterVenster::eindeHandler));
				venster_menubar->Append(Bestandmenu, _("Bestand"));
				Filtermenu = new wxMenu();
				Filtermenu->Append(BerekenFilterAktieID, _("Calculate Filter\tCtrl+B"), wxEmptyString);
				Connect(BerekenFilterAktieID, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(FilterVenster::berekenFilterHandler));
				Filtermenu->Append(ExporteerFilterImpulseBeeldID, _("Export the time domain image\tCtrl+R"), wxEmptyString);
				Connect(ExporteerFilterImpulseBeeldID, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(FilterVenster::exporteerFilterImpulsBeeldHandler));
				Filtermenu->Append(ExporteerFreqBeeldID, _("Export the frequency domain image\tCtrl+E"), wxEmptyString);
				Connect(ExporteerFreqBeeldID, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(FilterVenster::slaOpFreqBeeldHandler));
				Filtermenu->Append(wxID_SAVE, _("Write a C/CPP Header file"), wxEmptyString);
				Connect(wxID_SAVE, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(FilterVenster::slaOpFilterHandler));
				venster_menubar->Append(Filtermenu, _("Filter"));
				SetMenuBar(venster_menubar);
				tijdDomeinGrafiek = new GrafiekVenster(hoofdPaneel, TijdGrafiekVensterID, wxSize(TijdGrafiekBreedte,TijdGrafiekHoogte));
				tijdDomeinCoords = new wxStaticText(hoofdPaneel, TijdCoordID, _("Time domain coordinates (Mouse over window)"), wxDefaultPosition, wxDefaultSize, wxALIGN_CENTER);
				static_line_2 = new wxStaticLine(hoofdPaneel, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxLI_VERTICAL);
				freqDomeinGrafiek = new GrafiekVenster(hoofdPaneel, FreqGrafiekVensterID, wxSize(FreqGrafiekBreedte,FreqGrafiekHoogte));
				toonAnalogeFrequentiesCheckBox = new wxCheckBox(hoofdPaneel, ToonAnalogeFrequentiesID, _("Show analogue frequencies"));
				freqDomeinCoords = new wxStaticText(hoofdPaneel, FreqCoordID, _("Frequency domain coordinates (Mouse over window)"), wxDefaultPosition, wxDefaultSize, wxALIGN_CENTER);
				testGrafiek = new GrafiekVenster(testPaneel, TestGrafiekVensterID, wxSize(TestGrafiekBreedte,TestGrafiekHoogte));
				static_line_1 = new wxStaticLine(hoofdPaneel, wxID_ANY);
				sampFreqButton = new wxButton(hoofdPaneel, SampFreqID, _("Sampling frequency (Hz)"));
				sampFreqText = new wxStaticText(hoofdPaneel, SampFreqTextID, _("undetermined"));
				ordeButton = new wxButton(hoofdPaneel, FilterOrdeID, _("Filter order"));
				filterOrdeText = new wxStaticText(hoofdPaneel, FilterOrdeTextID, _("undetermined"));
				nulDBniveauTxt = new wxStaticText(hoofdPaneel, MaxVersterkingTextID, _("Supplemental filter amplification (dB) :"));
				maxVersterkingSpinCtrl = new wxSpinCtrl(hoofdPaneel, MaxVersterkingID, wxT("0"), wxDefaultPosition, wxDefaultSize, 0, -30, 30);
				vensterTypeText = new wxStaticText(hoofdPaneel, VensterKeuzeTekstID, _("Window applied :"));
				const wxString vensterChoice_choices[] = {
								_("Rectangle"),
								_("Triangle"),
								_("Hamming"),
				};
				vensterChoice = new wxChoice(hoofdPaneel, VensterKeuzeID, wxDefaultPosition, wxDefaultSize, 3, vensterChoice_choices);
				fipBitsText = new wxStaticText(hoofdPaneel, FIPBitsTekstID, _("Number of bits in coding :"));
				fipBitsSpinCtrl = new wxSpinCtrl(hoofdPaneel, FIPBitsID, wxT("3"), wxDefaultPosition, wxDefaultSize, 0, 3, 16);
				berekenFilterKnop = new wxButton(hoofdPaneel, BerekenFilterAktieID, _("Calculate filter"));
				toonfilterCoeffsCB = new wxCheckBox(hoofdPaneel, ToonfilterCoeffsCBID, _("Dump coefficients"));
				bandBeginSlider = new wxSlider(hoofdPaneel, BandBeginSliderID, 600, 400, 800, wxDefaultPosition, wxDefaultSize, wxSL_AUTOTICKS|wxSL_HORIZONTAL|wxSL_LABELS);
				bandEindeSlider = new wxSlider(hoofdPaneel, BandEindeSliderID, 600, 400, 800, wxDefaultPosition, wxDefaultSize, wxSL_AUTOTICKS|wxSL_HORIZONTAL|wxSL_LABELS);
				const wxString testSignaalChoice_choices[] = {
								_("Cosine"),
								_("Square wave"),
								_("Impulse"),
								_("Step"),
				};
				testSignaalChoice = new wxChoice(hoofdPaneel, TestSignaalKeuzeID, wxDefaultPosition, wxDefaultSize, 4, testSignaalChoice_choices);
				filterTestButton = new wxToggleButton(hoofdPaneel, FilterTestID, _("Start Filter Test"));
				testSignaalSlider = new wxSlider(hoofdPaneel, TestFreqID, 500, 0, 1600, wxDefaultPosition, wxDefaultSize, wxSL_AUTOTICKS|wxSL_HORIZONTAL|wxSL_LABELS|wxSL_LEFT|wxSL_RIGHT);
				testSignaalAmplitudeSlider = new wxSlider(hoofdPaneel, TestAmplitudeID, 1000, 0, 32767, wxDefaultPosition, wxDefaultSize, wxSL_AUTOTICKS|wxSL_HORIZONTAL|wxSL_LABELS|wxSL_LEFT|wxSL_RIGHT);
				tekenOrigineelCheckBox = new wxCheckBox(hoofdPaneel, TekenOrigineelID, _("Show test signal"));
				tekenSplineCheckBox = new wxCheckBox(hoofdPaneel, TekenSplineID, _("Draw interpolation spline"));
				button_1 = new wxButton(hoofdPaneel, wxID_EXIT, wxEmptyString);

				set_properties();
				do_layout();
				// end wxGlade

	filterConfig = (wxConfig *)wxConfigBase::Get(false);    /* verkrijg de globale config pointer */

//	tijdDomeinGrafiek->Bind(wxEVT_MOTION,&FilterVenster::tijdViewMuisBewegingHandler,this);
//	tijdDomeinGrafiek->Bind(wxEVT_ENTER_WINDOW,&FilterVenster::tijdViewBinnenkomstHandler,this);
//	tijdDomeinGrafiek->Bind(wxEVT_LEAVE_WINDOW,&FilterVenster::tijdViewBuitengangHandler,this);
//
//	freqDomeinGrafiek->Bind(wxEVT_MOTION,&FilterVenster::freqViewMuisBewegingHandler,this);
//	freqDomeinGrafiek->Bind(wxEVT_ENTER_WINDOW,&FilterVenster::freqViewBinnenkomstHandler,this);
//	freqDomeinGrafiek->Bind(wxEVT_LEAVE_WINDOW,&FilterVenster::freqViewBuitengangHandler,this);

	tijdDomeinGrafiek->Connect(TijdGrafiekVensterID, wxEVT_MOTION, wxMouseEventHandler(FilterVenster::OnMotion), NULL, this);
	tijdDomeinGrafiek->Connect(TijdGrafiekVensterID, wxEVT_ENTER_WINDOW, wxMouseEventHandler(FilterVenster::OnEnterWindow), NULL, this);
	tijdDomeinGrafiek->Connect(TijdGrafiekVensterID, wxEVT_LEAVE_WINDOW, wxMouseEventHandler(FilterVenster::OnLeaveWindow), NULL, this);
	freqDomeinGrafiek->Connect(FreqGrafiekVensterID, wxEVT_MOTION, wxMouseEventHandler(FilterVenster::OnMotion), NULL, this);
	freqDomeinGrafiek->Connect(FreqGrafiekVensterID, wxEVT_ENTER_WINDOW, wxMouseEventHandler(FilterVenster::OnEnterWindow), NULL, this);
	freqDomeinGrafiek->Connect(FreqGrafiekVensterID, wxEVT_LEAVE_WINDOW, wxMouseEventHandler(FilterVenster::OnLeaveWindow), NULL, this);


	/* lees filter voorkeurswaarden in */
	filterConfig->SetPath(wxT("/Configuratie/Filter"));

	int leeswaarde;

	filterConfig->Read(wxT("Sampling_Frequentie"),(int *)&sampFreq,500);
	filterConfig->Read(wxT("Startband"),(int *)&filterBegin,100);
	filterConfig->Read(wxT("Stopband"),(int *)&filterEind,140);

	filterConfig->Read(wxT("AantalTaps"),&leeswaarde,61);
	taps = leeswaarde;
	filterConfig->Read(wxT("Filterorde"),&leeswaarde,30);
	orde = leeswaarde;
	filterConfig->Read(wxT("MaxVersterking"),&leeswaarde,0);
	maxVersterkingSpinCtrl->SetValue(leeswaarde);

	filterConfig->Read(wxT("VensterKeuze"),&leeswaarde,0);
	vensterChoice->SetSelection(leeswaarde);
	filterConfig->Read(wxT("FixedPointBits"), &leeswaarde, 5);
	fipBitsSpinCtrl->SetValue(leeswaarde);

	filterConfig->Read(wxT("TestSignaal"),(int *)&leeswaarde,0);
	testSignaalChoice->SetSelection(leeswaarde);

	filterConfig->Read(wxT("Testfreq"),(int *)&testFreq,20);
	filterConfig->Read(wxT("Testampl"),(int *)&leeswaarde,1024);
	testAmplitude = leeswaarde;
	filterConfig->Read(wxT("TestOrig"),(bool *)&testOrig,false);
	filterConfig->Read(wxT("TestSpline"),(bool *)&testSpline,false);
	filterConfig->Read(wxT("Tooncoefficienten"),(bool *)&toonCoeffs,false);

	filterConfig->SetPath(wxT("/Configuratie/Paden"));

	const wxFileName standaard(wxGetHomeDir(),wxT("filter.h"));

	filterConfig->Read(wxT("DataPad"),&dataPad,standaard.GetFullPath());

	wxStaticText *label = (wxStaticText *)FindWindowById(SampFreqTextID,this);
	wxString tekst = wxString::Format(wxT("%d Hz"),sampFreq);
	wxCheckBox *check = (wxCheckBox *)FindWindowById(TekenOrigineelID,this);

	label->SetLabel(tekst);

	bandBeginSlider->SetRange(0,(sampFreq/2));
	wxLogDebug(wxT("Begin=%d"),filterBegin);
	bandBeginSlider->SetValue(filterBegin);

	bandEindeSlider->SetRange(1,(sampFreq/2));
	wxLogDebug(wxT("Begin=%d"),filterEind);
	bandEindeSlider->SetValue(filterEind);

	label = (wxStaticText *)FindWindowById(FilterOrdeTextID,this);
	tekst = wxString::Format(wxT("%d taps"),taps);
	label->SetLabel(tekst);

	testSignaalSlider->SetRange(1,4*sampFreq);
	testSignaalSlider->SetValue(testFreq);
	testSignaalAmplitudeSlider->SetValue(testAmplitude);

	check->SetValue(testOrig);
	check = (wxCheckBox *)FindWindowById(TekenSplineID,this);
	check->SetValue(testSpline);
	check = (wxCheckBox *)FindWindowById(ToonfilterCoeffsCBID,this);
	check->SetValue(toonCoeffs);

	label = (wxStaticText *)FindWindowById(FilterOrdeTextID,this);
	tekst = wxString::Format(_("Orde = %d (%d taps)"),orde,taps);
	label->SetLabel(tekst);

	tijdDomeinGrafiek->zetAssenPen(axisPen);
	tijdDomeinGrafiek->zetTekenPen(timeDomainPen);

	freqDomeinGrafiek->zetAssenPen(axisPen);
	freqDomeinGrafiek->zetTekenPen(freqDomainPen);

	tijdDomeinGrafiek->zetOorsprongMidden();
	freqDomeinGrafiek->zetOorsprong(wxRealPoint(0,0.75));
	testGrafiek->zetOorsprong(wxRealPoint(0,0.5));

	testGrafiek->zetGroteTekst(_("assignment4"),wxPoint(0, TestGrafiekHoogte/2));

}

FilterVenster::~FilterVenster()
{
	auto applikatie = reinterpret_cast<FirFilterKlasse *>(wxTheApp);
	applikatie->bewaarHoofdVensterGrootte();

	/* Initialiseer de configuratie */
	/* lees filter voorkeurswaarden in */
	filterConfig->SetPath(wxT("/Configuratie/Filter"));

	filterConfig->Write(wxT("Sampling_Frequentie"),sampFreq);
	filterConfig->Write(wxT("Startband"),filterBegin);
	filterConfig->Write(wxT("Stopband"),filterEind);
	filterConfig->Write(wxT("AantalTaps"),(int )taps);
	filterConfig->Write(wxT("Filterorde"),(int )orde);
	filterConfig->Write(wxT("MaxVersterking"),maxVersterkingSpinCtrl->GetValue());
	filterConfig->Write(wxT("VensterKeuze"),vensterChoice->GetSelection());
	filterConfig->Write(wxT("FixedPointBits"),fipBitsSpinCtrl->GetValue());

	filterConfig->Write(wxT("TestSignaal"),testSignaalChoice->GetSelection());
	filterConfig->Write(wxT("Testfreq"),(int )testFreq);
	filterConfig->Write(wxT("Testampl"),(int )testAmplitude);

	filterConfig->Write(wxT("TestOrig"),(bool )testOrig);
	filterConfig->Write(wxT("TestSpline"),(bool )testSpline);
	filterConfig->Write(wxT("Tooncoefficienten"),toonCoeffs);

	filterConfig->SetPath(wxT("/Configuratie/Paden"));

	filterConfig->Write(wxT("DataPad"),dataPad);


}

BEGIN_EVENT_TABLE(FilterVenster, wxFrame)
				// begin wxGlade: FilterVenster::event_table
				EVT_CHECKBOX(ToonAnalogeFrequentiesID, FilterVenster::toonAnalogeFreqsHandler)
				EVT_BUTTON(SampFreqID, FilterVenster::sampFreqHandler)
				EVT_BUTTON(FilterOrdeID, FilterVenster::filterOrdeHandler)
				EVT_SPINCTRL(MaxVersterkingID, FilterVenster::maxVersterkingHandler)
				EVT_CHOICE(VensterKeuzeID, FilterVenster::hammingVeranderdHandler)
				EVT_SPINCTRL(FIPBitsID, FilterVenster::maxVersterkingHandler)
				EVT_BUTTON(BerekenFilterAktieID, FilterVenster::berekenFilterHandler)
				EVT_CHECKBOX(ToonfilterCoeffsCBID, FilterVenster::toonCoefficientenHandler)
				EVT_COMMAND_SCROLL_LINEDOWN(BandBeginSliderID, FilterVenster::beginBandHandler)
				EVT_COMMAND_SCROLL_LINEUP(BandBeginSliderID, FilterVenster::beginBandHandler)
				EVT_COMMAND_SCROLL_PAGEDOWN(BandBeginSliderID, FilterVenster::beginBandHandler)
				EVT_COMMAND_SCROLL_PAGEUP(BandBeginSliderID, FilterVenster::beginBandHandler)
				EVT_COMMAND_SCROLL_THUMBRELEASE(BandBeginSliderID, FilterVenster::beginBandHandler)
				EVT_COMMAND_SCROLL_THUMBTRACK(BandBeginSliderID, FilterVenster::bandControleHandler)
				EVT_COMMAND_SCROLL_LINEDOWN(BandEindeSliderID, FilterVenster::eindeBandHandler)
				EVT_COMMAND_SCROLL_LINEUP(BandEindeSliderID, FilterVenster::eindeBandHandler)
				EVT_COMMAND_SCROLL_PAGEDOWN(BandEindeSliderID, FilterVenster::eindeBandHandler)
				EVT_COMMAND_SCROLL_PAGEUP(BandEindeSliderID, FilterVenster::eindeBandHandler)
				EVT_COMMAND_SCROLL_THUMBRELEASE(BandEindeSliderID, FilterVenster::eindeBandHandler)
				EVT_COMMAND_SCROLL_THUMBTRACK(BandEindeSliderID, FilterVenster::bandControleHandler)
				EVT_TOGGLEBUTTON(FilterTestID, FilterVenster::filterTestHandler)
				EVT_COMMAND_SCROLL_LINEDOWN(TestFreqID, FilterVenster::testFreqHandler)
				EVT_COMMAND_SCROLL_LINEUP(TestFreqID, FilterVenster::testFreqHandler)
				EVT_COMMAND_SCROLL_PAGEDOWN(TestFreqID, FilterVenster::testFreqHandler)
				EVT_COMMAND_SCROLL_PAGEUP(TestFreqID, FilterVenster::testFreqHandler)
				EVT_COMMAND_SCROLL_THUMBRELEASE(TestFreqID, FilterVenster::testFreqHandler)
				EVT_COMMAND_SCROLL_LINEDOWN(TestAmplitudeID, FilterVenster::testAmplHandler)
				EVT_COMMAND_SCROLL_LINEUP(TestAmplitudeID, FilterVenster::testAmplHandler)
				EVT_COMMAND_SCROLL_PAGEDOWN(TestAmplitudeID, FilterVenster::testAmplHandler)
				EVT_COMMAND_SCROLL_PAGEUP(TestAmplitudeID, FilterVenster::testAmplHandler)
				EVT_COMMAND_SCROLL_THUMBRELEASE(TestAmplitudeID, FilterVenster::testAmplHandler)
				EVT_COMMAND_SCROLL_THUMBTRACK(TestAmplitudeID, FilterVenster::testAmplHandler)
				EVT_BUTTON(wxID_EXIT, FilterVenster::eindeHandler)
				// end wxGlade

				EVT_UPDATE_UI(SampFreqID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(SampFreqTextID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(FilterOrdeID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(FilterOrdeTextID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(MaxVersterkingTextID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(MaxVersterkingID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(BandBeginSliderID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(BandEindeSliderID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(VensterKeuzeID, FilterVenster::bandUpdateHandler )
				EVT_UPDATE_UI(VensterKeuzeTekstID, FilterVenster::bandUpdateHandler)
				EVT_UPDATE_UI(FIPBitsTekstID, FilterVenster::bandUpdateHandler)
				EVT_UPDATE_UI(FIPBitsID, FilterVenster::bandUpdateHandler)

				EVT_UPDATE_UI(BerekenFilterAktieID, FilterVenster::berekenUpdateHandler )
				EVT_UPDATE_UI(FilterTestID, FilterVenster::testUpdateHandler )
				EVT_UPDATE_UI(wxID_SAVE, FilterVenster::testUpdateHandler )
				EVT_UPDATE_UI(wxID_PRINT, FilterVenster::testUpdateHandler )
				EVT_UPDATE_UI(TestFreqID, FilterVenster::testFreqGeldigHandler)
				EVT_UPDATE_UI(TestSignaalKeuzeID, FilterVenster::testOptiesUpdateHandler )
				EVT_UPDATE_UI(TekenOrigineelID, FilterVenster::testOptiesUpdateHandler )
				EVT_UPDATE_UI(TekenSplineID, FilterVenster::testOptiesUpdateHandler )


				EVT_UPDATE_UI(ExporteerFilterImpulseBeeldID,FilterVenster::testUpdateHandler)
				EVT_UPDATE_UI(ExporteerFreqBeeldID,FilterVenster::testUpdateHandler)

				EVT_TIMER(KlokVerlopenID, FilterVenster::klokVerlopenHandler)

END_EVENT_TABLE();

void FilterVenster::toonCopyrightHandler(wxCommandEvent &event)
{
	auto applikatie = reinterpret_cast<FirFilterKlasse *>(wxTheApp);
	applikatie->geefCopyright(_("Assignment 4 DSB Practicum"),
	                          _("Design and implement a FIR filter design tool based on the sinc() function."));
}

void FilterVenster::eindeHandler(wxCommandEvent &event)
{
	Close();
}

void FilterVenster::slaOpFilterHandler(wxCommandEvent &event)
{
	wxFileName bestand(dataPad);

	wxFileDialog dialoog(this,
	                     _("Save the filter design as a C or CPP header file"),
	                     bestand.GetPath(),
	                     bestand.GetFullName(),
	                     wxT("header file (*.h)|*.h"),
	                     wxFD_SAVE|wxFD_OVERWRITE_PROMPT|wxFD_CHANGE_DIR);

	if (wxID_OK == dialoog.ShowModal())
	{
		bestand = wxFileName(dataPad = dialoog.GetPath());

		if (wxString(wxT("h")) != bestand.GetExt())
		{
			bestand.SetExt(wxT("h"));
		}

		/* schrijf het bestand met deze bestandnaam */
		wxFileOutputStream stroom(bestand.GetFullPath());

		if (true != stroom.IsOk())
		{
			wxString fout = _("Could not open:") + bestand.GetFullName();
			wxLogError(fout);
		}

		else
		{
			wxTextOutputStream headerBestand( stroom );
			const wxDateTime nu(wxDateTime::Now());

			headerBestand.WriteString(wxT("/* Dit is een C/C++ Header bestand                                                                        */\n"));
			headerBestand.WriteString(wxT("/* Opdracht 4 Digitale Signaalbewerking/Digital Signal Processing  ESEDSP                                 */\n"));
			headerBestand.WriteString(wxT("/* Copyright 2006-2019 Opleiding Embedded Systems Engineering, Hogeschool van Arnhem en Nijmegen          */\n"));
			headerBestand.WriteString(wxT("/* Tijdstempel/Time Stamp : ")+nu.FormatISOCombined(' ')+wxT(" */\n"));
			headerBestand.WriteString(wxT("#ifndef FilterCoeffsExport_ESE_H\n"));
			headerBestand.WriteString(wxT("#define FilterCoeffsExport_ESE_H\n"));
#ifdef InterfaceTaalNederlands
			headerBestand.WriteString(wxString::Format(wxT("/* Onderstaande coefficienten zijn voor een bandpass Q%d fixed-point implementatie FIR filter */\n"), fipBitsSpinCtrl->GetValue()-1));
#elif defined(InterfaceTaalEnglish)
			headerBestand.WriteString(wxString::Format(wxT("/* The following coefficients are for a bandpass Q%d fixed-point implementation FIR filter */\n"), fipBitsSpinCtrl->GetValue()-1));
#endif
			headerBestand.WriteString(wxString::Format(wxT("/* Start vd band : %lf*PI (%d Hz @ fs=%d Hz) */\n"),(1.0f*filterBegin)/sampFreq,
			                                           static_cast<UInt32>(filterBegin), static_cast<UInt32>(sampFreq)));
			headerBestand.WriteString(wxString::Format(wxT("/* Eind vd band : %lf*PI (%d Hz @ fs=%d Hz) */\n"),(1.0f*filterEind)/sampFreq,
			                                           static_cast<UInt32>(filterEind), static_cast<UInt32>(sampFreq)));
			headerBestand.WriteString(wxString::Format(wxT("/* Taps : %d */\n\n"),taps));

			headerBestand.WriteString(wxT("\n\ntypedef signed short Int16;\n\n"));
#ifdef InterfaceTaalNederlands
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto AantalTaps=%d;\n"), taps));
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto SchaalFaktor=%d;\n\n"), berekenFixedPoint(1.0f)));
			headerBestand.WriteString(wxT("const Int16 filterFixedCoeffs[AantalTaps] = \n{\n"));
#elif defined(InterfaceTaalEnglish)
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto NumberOfTaps=%d;\n"), taps));
			headerBestand.WriteString(wxString::Format(wxT("static constexpr auto ScaleFactor=%d;\n\n"), computeFixedPoint(1.0f)));
			headerBestand.WriteString(wxT("const Int16 filterFixedCoeffs[NumberOfTaps] = \n{\n"));
#endif
			/* sla de fixed point coefficienten op. */

			for (unsigned int i=0;i<taps;i++)
			{
				const Int16 coeff = filterCoeffs[i];

				if (i == taps/2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));

				const wxString coeffString(wxString::Format(wxT("%d,"), coeff));

				headerBestand.WriteString(coeffString);

				if (i == taps / 2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));

				if ((0 != i) && (0 == i%5))
					headerBestand.WriteString(wxT("\n"));
			}

			headerBestand.WriteString(wxT("\n};\n\n"));

			/* sla de floating point coefficienten op. */
#ifdef InterfaceTaalNederlands
			headerBestand.WriteString(wxT("const float filterFloatCoeffs[AantalTaps] = \n{\n"));
#elif defined(InterfaceTaalEnglish)
			headerBestand.WriteString(wxT("const float filterFloatCoeffs[NumberOfTaps] = \n{\n"));
#endif
			for (unsigned int i = 0; i<taps; i++)
			{
#ifdef InterfaceTaalNederlands
				const float coeff = berekenFloatingPoint(filterCoeffs[i]);
#elif defined(InterfaceTaalEnglish)
				const float coeff = computeFloatingPoint(filterCoeffs[i]);
#endif
				if (i == taps / 2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));

				wxString coeffString(wxString::Format(wxT("%ff#"), coeff));
				/* vervang alle , door een .*/
				coeffString.Replace(wxT(","), wxT("."));
				coeffString.Replace(wxT("#"), wxT(","));
				headerBestand.WriteString(coeffString);

				if (i == taps / 2)
					headerBestand.WriteString(wxT("\n/* ===centrum coefficient=== */\n"));

				if ((0 != i) && (0 == i % 5))
					headerBestand.WriteString(wxT("\n"));
			}

			headerBestand.WriteString(wxT("\n};\n\n"));
			headerBestand.WriteString(wxT("#endif /* FilterCoeffsExport_ESE_H */\n\n"));

			wxLogMessage(_("Header file written succesfully."));
		}
	}
}

void FilterVenster::bandUpdateHandler(wxUpdateUIEvent &event)
{
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	/* als de situatie dat toelaat */
	event.Enable(((testSituatie != true) && (sampFreq != 0) && (taps != 0)));
}

void FilterVenster::berekenUpdateHandler(wxUpdateUIEvent &event)
{
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	const bool conditie = ((beginPuntBepaald == true) &&
	                       (eindPuntBepaald == true) &&
	                       (testSituatie != true) &&
	                       (berekeningKlaar != true));

	event.Enable(conditie);
}

void FilterVenster::testUpdateHandler(wxUpdateUIEvent &event)
{
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	/* wanneer berekeningKlaar op true wordt gezet */
	event.Enable((testSituatie == true) || (berekeningKlaar == true));
}

void FilterVenster::testFreqGeldigHandler(wxUpdateUIEvent &event)
{
	wxChoice const * const choice = reinterpret_cast<wxChoice *>(FindWindowById(TestSignaalKeuzeID,this));
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	/* wanneer berekeningKlaar op true wordt gezet */
	event.Enable(((testSituatie == true) || (berekeningKlaar == true)) &&(choice->GetSelection() < 2));
}

void FilterVenster::testOptiesUpdateHandler(wxUpdateUIEvent &event)
{
	/* Deze event handler zorgt er voor dat de knop pas zichtbaar wordt */
	/* wanneer berekeningKlaar op true wordt gezet */
	event.Enable(( (berekeningKlaar == true)&& (testSituatie != true)));
}




void FilterVenster::sampFreqHandler(wxCommandEvent &event)
{
	wxNumberEntryDialog dialoog(this,
	                            _("Specify the sampling frequency in Hz."),
	                            _("Frequency:"),
	                            _("The FIR filter system sampling frequency"),
	                            (int)sampFreq,
	                            1,
	                            64000);

	if (wxID_OK == dialoog.ShowModal())
	{
		wxStaticText *label = (wxStaticText *)FindWindowById(SampFreqTextID,this);
		wxSlider *slider;

		sampFreq = dialoog.GetValue();
		wxString tekst = wxString::Format(wxT("%d Hz"),sampFreq);
		label->SetLabel(tekst);

		/* reset begin en eind van de band als de frequenties niet meer passen */
		if (filterEind > sampFreq)
		{
			filterBegin = sampFreq / 8;
			filterEind = 3 * sampFreq / 8;
		}

		slider = (wxSlider *)FindWindowById(BandBeginSliderID,this);
		slider->SetRange(0,(sampFreq/2));
		slider->SetValue(filterBegin);

		slider = (wxSlider *)FindWindowById(BandEindeSliderID,this);
		slider->SetRange(1,(sampFreq/2));
		slider->SetValue(filterEind);

		slider = (wxSlider *)FindWindowById(TestFreqID,this);
		slider->SetRange(1,sampFreq);

		/* reset test freq als deze buiten het bereik valt */
		if (testFreq>(sampFreq))
			testFreq = sampFreq/4;

		slider->SetValue(testFreq);

		berekeningKlaar = false;
	}
}

void FilterVenster::maxVersterkingHandler(wxSpinEvent &event)
{
	berekeningKlaar = false;
}

void FilterVenster::hammingVeranderdHandler(wxCommandEvent &event)
{
	berekeningKlaar = false;
}

void FilterVenster::filterOrdeHandler(wxCommandEvent &event)
{

	wxNumberEntryDialog dialoog(this,
	                            _("Specify the order of the filter in number of taps."),
	                            _("Filter order:"),
	                            _("Taps in the FIR filter system"),
	                            ((taps-1)/2),1,200);

	if (wxID_OK == dialoog.ShowModal())
	{
		wxStaticText * const label = (wxStaticText *)FindWindowById(FilterOrdeTextID,this);

		orde = static_cast<UInt16>(dialoog.GetValue());
		taps = 2*orde + 1;

		const wxString tekst = wxString::Format(_("Orde = %d (%d taps)"),orde,taps);
		label->SetLabel(tekst);

		berekeningKlaar = false;
	}

}

void FilterVenster::testFreqHandler(wxScrollEvent &event)
{
	auto * slider = reinterpret_cast<wxSlider *>( FindWindowById(TestFreqID,this));
	testFreq = slider->GetValue();
}

void FilterVenster::testAmplHandler(wxScrollEvent &event)
{
	auto * slider = reinterpret_cast<wxSlider *>( FindWindowById(TestAmplitudeID,this));
	testAmplitude = static_cast<Int16>(slider->GetValue());
}

bool FilterVenster::bandControleRoutine(wxScrollEvent &event) const
{
	wxSlider * const beginSlider = (wxSlider *)FindWindowById(BandBeginSliderID,this);
	wxSlider * const eindeSlider = (wxSlider *)FindWindowById(BandEindeSliderID,this);

	const bool fout = (beginSlider->GetValue() >= eindeSlider->GetValue());
	if (true == fout)
	{
		const auto id = event.GetId();
		wxLogError(_("The start of the pass band must be smaller than the end."));

		if (id == BandBeginSliderID)
			beginSlider->SetValue(eindeSlider->GetValue()-1);
		else
			eindeSlider->SetValue(beginSlider->GetValue()+1);
	}

	return(fout);
}

void FilterVenster::bandControleHandler(wxScrollEvent &event)
{
	bandControleRoutine(event);
}

void FilterVenster::beginBandHandler(wxScrollEvent &event)
{
	if (false == bandControleRoutine(event))
	{
		auto * slider = reinterpret_cast<wxSlider *>(FindWindowById(BandBeginSliderID,this));

		const Frequentie freq = slider->GetValue();

		filterBegin = freq;
		beginPuntBepaald = true;
		berekeningKlaar = false;
	}
}


void FilterVenster::eindeBandHandler(wxScrollEvent &event)
{
	if (false == bandControleRoutine(event))
	{
		auto * slider = reinterpret_cast<wxSlider *>(FindWindowById(BandEindeSliderID,this));

		const Frequentie freq = slider->GetValue();

		filterEind = freq;
		eindPuntBepaald = true;
		berekeningKlaar = false;
	}
}

void FilterVenster::toonCoefficientenHandler(wxCommandEvent &event)
{
	wxCheckBox const * const cb = (wxCheckBox *)FindWindowById(ToonfilterCoeffsCBID,this);

	toonCoeffs = cb->GetValue();

	if ((0 != filterCoeffs.GetCount()) && (true == cb->IsChecked()))
	{
		for(signed int n=-1*orde;n<orde+1;n++)
		{
			const Int16 coeff = filterCoeffs[n+orde];

			wxLogMessage(wxString::Format(_("Coefficient[%d] = %d (float:%f)"),n,coeff,computeFloatingPoint(coeff)));
		}
	}
}


void FilterVenster::tijdViewBinnenkomstHandler(wxMouseEvent &event)
{
	const bool conditie = ((beginPuntBepaald == true) &&
	                       (eindPuntBepaald == true) &&
	                       (testSituatie != true) &&
	                       (berekeningKlaar == true));

	if (true == conditie)
	{
		wxLogDebug(_("Time graph entry."));
	}
	FindWindowById(BandBeginSliderID,this);
	tijdDomeinCoords->Enable(conditie);
}

void FilterVenster::tijdViewBuitengangHandler(wxMouseEvent &event)
{
	wxLogDebug(_("Time graph exit."));
	tijdDomeinCoords->Enable(false);
	tijdDomeinCoords->SetLabel(_("No coordinates"));
}

void FilterVenster::freqViewBinnenkomstHandler(wxMouseEvent &event)
{
	const bool conditie = ((beginPuntBepaald == true) &&
	                       (eindPuntBepaald == true) &&
	                       (testSituatie != true) &&
	                       (berekeningKlaar == true));

	if (true == conditie)
	{
		wxLogDebug(_("Freq graph entry."));
	}

	freqDomeinCoords->Enable(conditie);
}

void FilterVenster::freqViewBuitengangHandler(wxMouseEvent &event)
{
	wxLogDebug(_("Freq graph exit."));
	freqDomeinCoords->Enable(false);
	freqDomeinCoords->SetLabel(_("No coordinates"));
}

void FilterVenster::toonAnalogeFreqsHandler(wxCommandEvent &event)
{
#ifdef InterfaceTaalNederlands
	tekenFreqSpectrum();
#elif defined(InterfaceTaalEnglish)
	drawFreqSpectrum();
#endif
}

void FilterVenster::slaOpFreqBeeldHandler(wxCommandEvent &event)
{
	freqDomeinGrafiek->slaOpVeld();
}

void FilterVenster::exporteerFilterImpulsBeeldHandler(wxCommandEvent &event)
{
	tijdDomeinGrafiek->slaOpVeld();
}

void FilterVenster::filterTestHandler(wxCommandEvent &event)
{
	auto *  knop = reinterpret_cast<wxToggleButton *>(FindWindowById(FilterTestID, this));

	const bool knopStand = knop->GetValue();

	if (knopStand == true)
	{
		filterStart();
	}
	else
	{
		filterStop();
	}
}

void FilterVenster::filterStart()
{
	auto * knop = reinterpret_cast<wxToggleButton *>(FindWindowById(FilterTestID, this));
	auto * origBox = reinterpret_cast<wxCheckBox *>(FindWindowById(TekenOrigineelID, this));
	auto * splineBox = reinterpret_cast<wxCheckBox *>(FindWindowById(TekenSplineID, this));

	testOrig = origBox->GetValue();
	testSpline = splineBox->GetValue();

	knop->SetLabel(wxT("Stop FilterTest"));

	const RingBuffer<Int16> coeffs(filterCoeffs.Count(), &filterCoeffs[0]);

#ifdef InterfaceTaalNederlands
	const auto precisie = berekenFixedPoint(1.0f);
#elif defined(InterfaceTaalEnglish)
	const auto precisie = computeFixedPoint(1.0f);
#endif

	filter = new FilterFirInt16(coeffs,precisie);
	testSituatie = true;
	testIndex = testTekenIndex = 0;
	testGrafiek->maakSchoon();
	filter->reset();
	filterSignaalLijst.Empty();
	klok.Start(100);

	/* als "coeffs" uit skoop gaat, dan blijven de pointers toch geldig omdat deze aan filterCoeffs hangen. */
}

void FilterVenster::filterStop()
{
	wxToggleButton * const knop = (wxToggleButton *)FindWindowById(FilterTestID, this);

	knop->SetValue(false);
	knop->SetLabel(wxT("Start FilterTest"));

	klok.Stop();

	testSituatie = false;

	/* voor demoversie */
	testGrafiek->zetGroteTekst(_("Demoversion"), wxPoint(100, TestGrafiekHoogte / 2));

	delete filter;
}

void FilterVenster::klokVerlopenHandler(wxTimerEvent &event)
{
	static const wxSize grootte(TestGrafiekBreedte,TestGrafiekHoogte);
	//const Int16 fipSchaal = ; //  testAmplitude; //(MaximumBereikSignedInt(sizeof(Int16))-100)/64;
	static const double schaaly = TestGrafiekHoogte/(2.0*testSignaalAmplitudeSlider->GetMax());

	Int16 orig;

	switch(testSignaalChoice->GetSelection())
	{
		case 0:  /* cosinus */
			orig = static_cast<Int16>(testAmplitude*cos(2*Pi*testIndex*testFreq/sampFreq));
			break;
		case 1: /* blokgolf */
			orig = static_cast<Int16>(testAmplitude*cos(2*Pi*testIndex*testFreq/sampFreq));
			orig = ((orig > 0) ? testAmplitude : -1* testAmplitude);
			break;
		case 2: /* impuls */
			orig = ((testIndex==4) ? testAmplitude : 0);
			break;
		case 3: /* stap */
			orig = ((testIndex<4) ? 0 : testAmplitude);
			break;
		default:
			orig=0;
			wxFAIL_MSG(wxT("Mag hier niet komen !!"));
			break;
	}

	const Int16 filterOutput = filter->filter(orig);
	wxLogDebug(wxString::Format(wxT("orig=%d,filter=%d"),orig,filterOutput));

	testIndex++;

	const wxPoint filterPunt(testTekenIndex+4, static_cast<int>(filterOutput*schaaly));

	/* voeg punt toe om aan het eind tekensessie de spline mee te tekenen */
	if (testSpline==true)
		filterSignaalLijst.Add(filterPunt);

	if (testTekenIndex == 0)
	{
		testGrafiek->maakSchoon();
		testGrafiek->zetGroteTekst(_("Assignment 4"),wxPoint(100, TestGrafiekHoogte / 2));
	}

	if (true == testOrig)  /* teken ook het originele signaal */
	{
		const wxPoint origPunt(testTekenIndex,static_cast<int>(orig*schaaly));
		testGrafiek->zetTekenPen(originalSignalPen);
		testGrafiek->tekenStaaf(origPunt);
	}

	testGrafiek->zetTekenPen(filterdSignalPen);
	testGrafiek->tekenStaaf(filterPunt);

	testTekenIndex+=8;

	if (testTekenIndex>(Teller)grootte.GetWidth())
	{
		if ((testSpline==false) && (testSignaalChoice->GetSelection() < 2))
			testTekenIndex=0;  /* bij cosinus en blokgolf, keer om */
		else
		{
			if (testSpline == true)
				testGrafiek->tekenSpline(filterSignaalLijst);

			/* stop de test */
			filterStop();
		}
	}
}

// wxGlade: add FilterVenster event handlers
void FilterVenster::set_properties()
{
				// begin wxGlade: FilterVenster::set_properties
				SetTitle(_("Fixed Point FIR band pass filter"));
				tijdDomeinGrafiek->SetMinSize(wxSize(500, 200));
				tijdDomeinCoords->Enable(0);
				freqDomeinGrafiek->SetMinSize(wxSize(500, 200));
				freqDomeinCoords->Enable(0);
				testGrafiek->SetMinSize(wxSize(1000, 200));
				testPaneel->SetMinSize(wxSize(600,50));
				testPaneel->SetScrollRate(10, 10);
				sampFreqButton->SetDefault();
				vensterChoice->SetSelection(0);
				berekenFilterKnop->Enable(0);
				berekenFilterKnop->SetDefault();
				toonfilterCoeffsCB->SetValue(1);
				bandBeginSlider->Enable(0);
				bandEindeSlider->Enable(0);
				testSignaalChoice->SetSelection(0);
				tekenSplineCheckBox->SetValue(1);
				hoofdPaneel->SetBackgroundColour(wxColour(47, 180, 255));
				// end wxGlade

}


void FilterVenster::do_layout()
{
				// begin wxGlade: FilterVenster::do_layout
				wxBoxSizer* hoofdSizer = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* hoofdOndersizer = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* beginOndersizer = new wxBoxSizer(wxVERTICAL);
				wxBoxSizer* sizer_2 = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* sizer_17 = new wxBoxSizer(wxVERTICAL);
				wxStaticBoxSizer* sizer_9 = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Filter test")), wxVERTICAL);
				wxBoxSizer* sizer_6_copy = new wxBoxSizer(wxVERTICAL);
				wxBoxSizer* sizer_14 = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* sizer_6 = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* sizer_6_copy_1 = new wxBoxSizer(wxHORIZONTAL);
				wxStaticBoxSizer* signaalAmpSizer = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Test Signal amplitude")), wxVERTICAL);
				wxStaticBoxSizer* signaalFreqSizer = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Test Signal frequency")), wxVERTICAL);
				wxBoxSizer* sizer_15 = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* sizer_8 = new wxBoxSizer(wxVERTICAL);
				wxStaticBoxSizer* sizer_5 = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Filter parameters")), wxVERTICAL);
				wxBoxSizer* sizer_13 = new wxBoxSizer(wxHORIZONTAL);
				wxBoxSizer* sizer_12 = new wxBoxSizer(wxVERTICAL);
				wxStaticBoxSizer* sizer_11 = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Band pass end (Hz)")), wxVERTICAL);
				wxStaticBoxSizer* sizer_4 = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Band pass begin (Hz)")), wxVERTICAL);
				wxBoxSizer* sizer_16 = new wxBoxSizer(wxVERTICAL);
				wxBoxSizer* sizer_10 = new wxBoxSizer(wxHORIZONTAL);
				wxFlexGridSizer* optiesGridSizer = new wxFlexGridSizer(5, 2, 5, 5);
				wxStaticBoxSizer* testSizer = new wxStaticBoxSizer(new wxStaticBox(testPaneel, wxID_ANY, _("Testsignaal")), wxHORIZONTAL);
				wxBoxSizer* sizer_3 = new wxBoxSizer(wxHORIZONTAL);
				wxStaticBoxSizer* freqSizer = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Frequency domain representation")), wxVERTICAL);
				wxBoxSizer* sizer_1 = new wxBoxSizer(wxVERTICAL);
				wxStaticBoxSizer* sizer_7 = new wxStaticBoxSizer(new wxStaticBox(hoofdPaneel, wxID_ANY, _("Time domain filter impulse response")), wxVERTICAL);
				sizer_7->Add(tijdDomeinGrafiek, 1, wxALL|wxEXPAND, 5);
				sizer_7->Add(tijdDomeinCoords, 0, wxALL|wxEXPAND, 5);
				sizer_3->Add(sizer_7, 0, wxEXPAND, 0);
				sizer_3->Add(static_line_2, 0, wxEXPAND, 0);
				freqSizer->Add(freqDomeinGrafiek, 1, wxALL|wxEXPAND, 5);
				sizer_1->Add(toonAnalogeFrequentiesCheckBox, 0, 0, 0);
				sizer_1->Add(freqDomeinCoords, 0, wxALL|wxEXPAND, 5);
				freqSizer->Add(sizer_1, 0, 0, 0);
				sizer_3->Add(freqSizer, 2, wxEXPAND, 0);
				beginOndersizer->Add(sizer_3, 0, wxEXPAND, 0);
				testSizer->Add(testGrafiek, 1, wxEXPAND|wxFIXED_MINSIZE, 0);
				testPaneel->SetSizer(testSizer);
				beginOndersizer->Add(testPaneel, 1, wxEXPAND|wxFIXED_MINSIZE, 0);
				beginOndersizer->Add(static_line_1, 0, wxEXPAND, 0);
				optiesGridSizer->Add(sampFreqButton, 0, 0, 5);
				optiesGridSizer->Add(sampFreqText, 0, wxALIGN_CENTER_VERTICAL, 0);
				optiesGridSizer->Add(ordeButton, 0, 0, 5);
				optiesGridSizer->Add(filterOrdeText, 0, wxALIGN_CENTER_VERTICAL, 0);
				optiesGridSizer->Add(nulDBniveauTxt, 0, 0, 5);
				optiesGridSizer->Add(maxVersterkingSpinCtrl, 0, 0, 0);
				optiesGridSizer->Add(vensterTypeText, 0, 0, 5);
				optiesGridSizer->Add(vensterChoice, 0, 0, 0);
				optiesGridSizer->Add(fipBitsText, 0, 0, 5);
				optiesGridSizer->Add(fipBitsSpinCtrl, 0, wxALL, 0);
				sizer_16->Add(optiesGridSizer, 0, wxEXPAND, 0);
				sizer_10->Add(berekenFilterKnop, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5);
				sizer_10->Add(toonfilterCoeffsCB, 1, wxALIGN_CENTER_VERTICAL|wxALL, 5);
				sizer_16->Add(sizer_10, 0, wxEXPAND, 0);
				sizer_13->Add(sizer_16, 1, wxEXPAND, 0);
				sizer_4->Add(bandBeginSlider, 1, wxEXPAND, 5);
				sizer_12->Add(sizer_4, 0, wxALL|wxEXPAND, 5);
				sizer_11->Add(bandEindeSlider, 1, wxEXPAND, 5);
				sizer_12->Add(sizer_11, 0, wxALL|wxEXPAND, 5);
				sizer_13->Add(sizer_12, 0, wxEXPAND, 0);
				sizer_5->Add(sizer_13, 1, wxEXPAND, 0);
				sizer_8->Add(sizer_5, 0, wxEXPAND, 0);
				sizer_2->Add(sizer_8, 0, wxEXPAND, 0);
				sizer_15->Add(testSignaalChoice, 1, wxALL|wxEXPAND, 5);
				sizer_15->Add(filterTestButton, 0, wxALL|wxEXPAND, 5);
				sizer_9->Add(sizer_15, 0, wxEXPAND, 0);
				signaalFreqSizer->Add(testSignaalSlider, 1, wxBOTTOM|wxEXPAND, 10);
				sizer_6->Add(signaalFreqSizer, 0, wxALL, 5);
				signaalAmpSizer->Add(testSignaalAmplitudeSlider, 1, wxBOTTOM|wxEXPAND, 10);
				sizer_6_copy_1->Add(signaalAmpSizer, 1, wxALL, 5);
				sizer_6->Add(sizer_6_copy_1, 0, 0, 0);
				sizer_6_copy->Add(sizer_6, 1, 0, 0);
				sizer_14->Add(tekenOrigineelCheckBox, 0, wxALL, 5);
				sizer_14->Add(tekenSplineCheckBox, 0, wxALL, 5);
				sizer_6_copy->Add(sizer_14, 0, wxEXPAND, 0);
				sizer_9->Add(sizer_6_copy, 1, 0, 0);
				sizer_17->Add(sizer_9, 0, 0, 3);
				sizer_17->Add(button_1, 0, wxALL|wxEXPAND, 5);
				sizer_2->Add(sizer_17, 1, wxEXPAND, 0);
				beginOndersizer->Add(sizer_2, 0, wxEXPAND, 0);
				hoofdOndersizer->Add(beginOndersizer, 1, wxEXPAND, 0);
				hoofdPaneel->SetSizer(hoofdOndersizer);
				hoofdSizer->Add(hoofdPaneel, 1, wxALL|wxEXPAND, 5);
				SetSizer(hoofdSizer);
				hoofdSizer->Fit(this);
				hoofdSizer->SetSizeHints(this);
				Layout();
				// end wxGlade
}





